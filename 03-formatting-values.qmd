# Formatting the values within a table

```{r setup, include=FALSE, echo=FALSE}
library(gt)
```

*** General introduction to the formatting pipeline

The presentation of values in the body and in the stub of the table is undoubtedly important when it comes to making tables for display purposes. Whereas table components like the header, the footer, and the column labels also need attention, the data values comprise the bulk of the information. And information that is not carefully presented can be difficult for the reader to parse or, worse, misleading.

The **gt** package takes a multi-stage approach to rendering values. In a latter part of the book we'll describe all of the stages (and do it in great detail) but at this point, it's important to outline how three groups of functions work within this build system. These functions are classified as:

1. formatting functions (`fmt_*()`)
2. substitution functions (`sub_*()`)
3. text transformation functions (`text_*()`)

And the rendering of values via functions in those groups operates in that order (i.e., formatting first, then substitution, then text transformation). Why such rigor and formality in what might be thought as a mundane operation? Well, we all want flexibility in how we present our data. After all, the presentation of data in the body is of paramount importance, so we need a system that gives us a wealth of functionality and opportunities for fine adjustments and tweaks where necessary. We also want **gt** to be easy to use, so the opportunity is there to use a little or a lot of this machinery.

Here's an example where we modify a single column of values with a function from each of the groups:

```r
"Example"
```



Formatting body cells is commonly done with the family of formatting functions (e.g., `fmt_number()`, `fmt_date()`, etc.). The package supports formatting with internationalization ('i18n' features) and so any locale-aware functions (and many of the formatting variety) come with a `locale` argument. To avoid having to use that argument repeatedly, the `gt()` function has its own locale argument. Setting a locale in that will make it available globally. Here's an example of how that works in practice when setting `locale = "fr"` in `gt()` and using formatting functions:

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group",
    locale = "fr"
  ) |>
  fmt_number() |>
  fmt_date(
    columns = date,
    date_style = "yMEd"
  ) |>
  fmt_datetime(
    columns = datetime,
    format = "EEEE, MMMM d, y",
    locale = "en"
  )
```

In this example, the `fmt_number()` and `fmt_date()` functions understand that the locale for this table is `"fr"` (French), so the appropriate formatting for that locale is apparent in the `num`, `currency`, and `date` columns. However in the `fmt_datetime()` call, we explicitly use the `"en"` (English) locale. This overrides the `"fr"` default set for this table and the end result is dates formatted with the English locale in the datetime column.

## Basic number formatting

*** General introduction to basic number formatting

### `fmt_number()`

Number-based formatting in a **gt** table can be generally performed with the `fmt_number()` function. With this any targeted, numeric values can be rendered with a higher consideration for tabular presentation. What this means is that we have fine control over how numbers are going to appear, and here are some of the main features available in the function:

- choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol

- the option to enable/disable digit separators and also to choose the separator symbol

- we can choose to scale targeted values by a multiplier value

- compact numbers: larger figures (thousands, millions, etc.) can be autoscaled and decorated with the appropriate suffixes

- with a text pattern, the formatted values can be decorated with literal characters

- locale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale


```r
fmt_number(
  data,
  columns = everything(),
  rows = everything(),
  decimals = 2,
  n_sigfig = NULL,
  drop_trailing_zeros = FALSE,
  drop_trailing_dec_mark = TRUE,
  use_seps = TRUE,
  accounting = FALSE,
  scale_by = 1,
  suffixing = FALSE,
  pattern = "{x}",
  sep_mark = ",",
  dec_mark = ".",
  force_sign = FALSE,
  system = c("intl", "ind"),
  locale = NULL
)
```



### `fmt_integer()`


### `fmt_percent()`



## Scientific and engineering formats

*** General introduction to scientific and engineering number formatting

### `fmt_scientific()`


### `fmt_engineering()`



## Formatting numbers to currencies and various other units

*** General introduction to currency and other symbol-adding formatting functions

### `fmt_currency()`


### `fmt_bytes()`


### `fmt_partsper()`



## Translating numbers to other forms

*** General introduction to formatting whole numbers to different textual representations

### `fmt_index()`


### `fmt_roman()`


### `fmt_num_spelled()`



## Date, time, and duration formats

*** General introduction to formatting as dates, times, and durations

### `fmt_date()`


### `fmt_time()`


### `fmt_datetime()`


### `fmt_duration()`



## Formatting with Markdown, creating links, adding images


### `fmt_markdown()`


### `fmt_url()`


### `fmt_image()`



## Creating your own formatter


### `fmt()`


## Substitution Functions


### `sub_missing()`


### `sub_zero()`


### `sub_small_vals()`


### `sub_large_vals()`


### `sub_values()`


## Text transformations


### `text_replace()`


### `text_case_when()`


### `text_case_match()`


### `text_transform()`

