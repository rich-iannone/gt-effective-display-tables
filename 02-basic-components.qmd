# Basic components of a table and how to incorporate those

```{r setup, include=FALSE, echo=FALSE}
library(gt)
library(dplyr)
library(tidyr)
```

## Making a **gt** table: the `gt()` function is the entry point

When one provides table data to the `gt()` function, it generates a **gt** table object. This function is the initial step in a typical **gt** workflow. Once you possess the **gt** table object, you have the ability to perform styling transformations before rendering it as a display table of different formats.

Let's use the `exibble` dataset for the next few examples, we'll learn how to make simple **gt** tables with the `gt()` function. The most basic thing to do is to just use `gt()` with the dataset as the input.

```{r}
exibble |> gt()
```

This dataset has the row and group columns. The former contains unique values that are ideal for labeling rows, and this often happens in what is called the 'stub' (a reserved area that serves to label rows). With the `gt()` function, we can immediately place the contents of the row column into the stub column. To do this, we use the `rowname_col` argument with the name of the column to use in quotes.

```{r}
exibble |> gt(rowname_col = "row")
```

This sets up a table with a stub, the row labels are placed within the stub column, and a vertical dividing line has been placed on the right-hand side.

The `group` column can be used to divide the rows into discrete groups. Within that column, we see repetitions of the values `"grp_a"` and `"grp_b"`. These serve both as ID values and the initial label for the groups. With the `groupname_col` argument in `gt()`, we can set up the row groups immediately upon creation of the table.

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group"
  )
```

If you'd rather perform the set up of row groups later (i.e., not in the `gt()` call), this is possible with use of the `tab_row_group()` function (and `row_group_order()` can help with the arrangement of row groups).

One more thing to consider with row groups is their layout. By default, row group labels reside in separate rows the appear above the group. However, we can use the `row_group_as_column = TRUE` option to put the row group labels within a secondary column within the table stub.

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group",
    row_group_as_column = TRUE
  )
```

This could be done later if need be, and using `tab_options(row_group.as_column = TRUE)` would be the way to do it outside of the `gt()` call.

Some datasets have rownames built in; `mtcars` famously has the car model names as the rownames. To use those rownames as row labels in the stub, the `rownames_to_stub = TRUE` option will prove to be useful.

```{r}
head(mtcars, 10) |> gt(rownames_to_stub = TRUE)
```

By default, values in the body of a **gt** table (and their column labels) are automatically aligned. The alignment is governed by the types of values in a column. If you'd like to disable this form of auto-alignment, the `auto_align = FALSE` option can be taken.

```{r}
exibble |> gt(rowname_col = "row", auto_align = FALSE)
```

What you'll get from that is center-alignment of all table body values and all column labels. Note that row labels in the the stub are still left-aligned; and auto_align has no effect on alignment within the table stub.

However which way you generate the initial gt table object, you can use it with a huge variety of functions in the package to further customize the presentation. Formatting body cells is commonly done with the family of formatting functions (e.g., fmt_number(), fmt_date(), etc.). The package supports formatting with internationalization ('i18n' features) and so locale-aware functions come with a locale argument. To avoid having to use that argument repeatedly, the gt() function has its own locale argument. Setting a locale in that will make it available globally. Here's an example of how that works in practice when setting locale = "fr" in gt() and using formatting functions:

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group",
    locale = "fr"
  ) |>
  fmt_number() |>
  fmt_date(
    columns = date,
    date_style = "yMEd"
  ) |>
  fmt_datetime(
    columns = datetime,
    format = "EEEE, MMMM d, y",
    locale = "en"
  )
```

In this example, the `fmt_number()` and `fmt_date()` functions understand that the locale for this table is `"fr"` (French), so the appropriate formatting for that locale is apparent in the `num`, `currency`, and `date` columns. However in the `fmt_datetime()` call, we explicitly use the `"en"` (English) locale. This overrides the `"fr"` default set for this table and the end result is dates formatted with the English locale in the datetime column.

## The table header and footer

- `tab_header()` and `opt_align_header()`

It is possible to add a table header to the **gt** table, which includes a title and even a subtitle. The table header is an optional component of the table that appears above the column labels. You have the flexibility to use Markdown formatting for the header's title and subtitle, allowing for greater customization. Additionally, if you intend to use HTML output for the table, you may utilize HTML in either the title or subtitle.

Use the `gtcars` dataset to create a **gt** table. Add a header part to the
table with the `tab_header()` function. We'll add a title and the optional
subtitle as well. With the `md()` helper function, we can make sure the
Markdown formatting is interpreted and transformed.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title = md("Data listing from **gtcars**"),
    subtitle = md("`gtcars` is an R dataset")
  )
```

If the table is intended solely as an HTML table, you could introduce your
own HTML elements into the header. You can even use the **htmltools** package
to help arrange and generate the HTML. Here's an example of that, where two
`<div>` elements are placed in a `htmltools::tagList()`.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title =
      htmltools::tagList(
        htmltools::tags$div(
          style = htmltools::css(
            `text-align` = "center"
          ),
          htmltools::HTML(
            web_image("https://www.r-project.org/logo/Rlogo.png")
          )
        ),
        htmltools::tags$div(
          "Data listing from ",
          htmltools::tags$strong("gtcars")
        )
      )
  )
```

If using HTML but doing something far simpler, we can use the `html()` helper
function to declare that the text provided is HTML.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title = html("Data listing from <strong>gtcars</strong>"),
    subtitle = html("From <span style='color:red;'>gtcars</span>")
  )
```

The table header that is appended to a **gt** table typically has center alignment for both the title and subtitle elements. However, it is possible to adjust the horizontal alignment of the title and subtitle by utilizing the `align` argument. This function provides a quick and easy means to set the alignment to the left or right. It also serves as a convenient shortcut for `<gt_tbl> |> tab_options(heading.align = <align>)`.

```{r}
exibble |>
  gt(rowname_col = "row", groupname_col = "group") |>
  tab_header(
    title = "The title of the table",
    subtitle = "The table's subtitle"
  ) |>
  opt_align_table_header(align = "left")
```

- `tab_source_note()`


## Grouping together column labels with spanners

- `tab_spanner()`

Let's create a **gt** table using a small portion of the `gtcars` dataset.
Over several columns (`hp`, `hp_rpm`, `trq`, `trq_rpm`, `mpg_c`, `mpg_h`)
we'll use `tab_spanner()` to add a spanner with the label `"performance"`.
This effectively groups together several columns related to car performance
under a unifying label.

```{r}
gtcars |>
  dplyr::select(
    -mfr, -trim, bdy_style,
    -drivetrain, -trsmn, -ctry_origin
  ) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_spanner(
    label = "performance",
    columns = c(
      hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h
    )
  )
```

With the default `gather = TRUE` option, columns selected for a particular
spanner will be moved so that there is no separation between them. This can
be seen with the example below that uses a subset of the `towny` dataset.
The starting column order is `name`, `latitude`, `longitude`,
`population_2016`, `density_2016`, `population_2021`, and `density_2021`. The
first two uses of `tab_spanner()` deal with making separate spanners for the
two population and two density columns. After their use, the columns are
moved to this new ordering: `name`, `latitude`, `longitude`,
`population_2016`, `population_2021`, `density_2016`, and `density_2021`. The
third and final call of `tab_spanner()` doesn't further affect the ordering
of columns.

```{r}
towny |>
  dplyr::arrange(desc(population_2021)) |>
  dplyr::slice_head(n = 5) |>
  dplyr::select(
    name, latitude, longitude,
    ends_with("2016"), ends_with("2021")
  ) |>
  gt() |>
  tab_spanner(
    columns = starts_with("pop"),
    label = "Population"
  ) |>
  tab_spanner(
    columns = starts_with("den"),
    label = "Density"
  ) |>
  tab_spanner(
    columns = ends_with("itude"),
    label = md("*Location*"),
    id = "loc"
  )
```

While columns are moved, it is only the minimal amount of moving required
(pulling in columns from the right) to ensure that columns are gathered under
the appropriate spanners. With the last call, there are two more things to
note: (1) `label` values can use the `md()` (or `html()`) helper functions to
help create styled text, and (2) an `id` value may be supplied for reference
later (e.g., for styling with `tab_style()` or applying footnotes with
`tab_footnote()`).

It's possible to stack multiple spanners atop each other with consecutive
calls of `tab_spanner()`. It's a bit like playing Tetris: putting a spanner
down anywhere there is another spanner (i.e., there are one or more shared
columns) means that second spanner will reside a level above prior. Let's
look at a few examples at how this works, and we'll also explore a few
lesser-known placement tricks. Let's use a cut down version of `exibble`
for this, set up a few level-one spanners, and then place a level two spanner
over two other spanners.

```{r}
exibble_narrow <- exibble |> dplyr::slice_head(n = 3)

exibble_narrow |>
  gt() |>
  tab_spanner(
    label = "Row Information",
    columns = c(row, group)
  ) |>
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |>
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |>
  tab_spanner(
    label = "Numbers and Text",
    spanners = c("num_spanner", "text_spanner")
  )
```

In the above example, we used the `spanners` argument to define where the
`"Numbers and Text"`-labeled spanner should reside. For that, we supplied the
`"num_spanner"` and `"text_spanner"` ID values for the two spanners
associated with the `num`, `currency`, `char`, and `fctr` columns.
Alternatively, we could have given those column names to the `columns`
argument and achieved the same result. You could actually use a combination
of `spanners` and `columns` to define where the spanner should be placed.
Here is an example of just that:

```{r}
exibble_narrow_gt <-
  exibble_narrow |>
  gt() |>
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |>
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |>
  tab_spanner(
    label = "Text, Dates, Times, Datetimes",
    columns = contains(c("date", "time")),
    spanners = "text_spanner"
  )
  
exibble_narrow_gt
```

And, again, we could have solely supplied all of the column names to
`columns` instead of using this hybrid approach, but it is interesting to
express the definition of spanners with this flexible combination.
What if you wanted to extend the above example and place a spanner above the
`date`, `time`, and `datetime` columns? If you tried that in the manner as
exemplified above, the spanner will be placed in the third level of spanners:

```{r}
exibble_narrow_gt |>
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    id = "date_time_spanner"
  )
```

Remember that the approach taken by `tab_spanner()` is to keep stacking atop
existing spanners. But, there is space next to the `"Text Values"` spanner on
the first level. You can either revise the order of `tab_spanner()` calls,
or, use the `level` argument to force the spanner into that level (so long
as there is space).

```{r}
exibble_narrow_gt |>
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    level = 1,
    id = "date_time_spanner"
  )
```

That puts the spanner in the intended level. If there aren't free locations
available in the `level` specified you'll get an error stating which columns
cannot be used for the new spanner (this can be circumvented, if necessary,
with the `replace = TRUE` option). If you choose a level higher than the
maximum occupied, then the spanner will be dropped down. Again, these
behaviors are indicative of Tetris-like rules though they tend to work well
for the application of spanners.

- `tab_spanner_delim()`

The `cols_spanner_delim()` function can take specially-crafted column names and generate one or more spanner column labels (along with relabeling the column labels). This is done by splitting the column name by a specified delimiter character (this is the `delim`) and placing the fragments from top to bottom (i.e., higher-level spanners to the column labels). Furthermore, the neighboring text fragments on different spanner levels will be coalesced together to put the span back into spanner. For instance, having the three side-by-side column names `rating_1`, `rating_2`, and `rating_3` will (in the default case at least) result in a spanner with the label `"rating"` above columns with the labels `"1"`, `"2"`, and `"3"`.

If we take a hypothetical table that includes the column names `province.NL_ZH.pop`, `province.NL_ZH.gdp`, `province.NL_NH.pop`, and `province.NL_NH.gdp`, we can see that we have a naming system that has a well-defined structure. We start with the more general to the left (`"province"`) and move to the more specific on the right (`"pop"`). If the columns are in the table in this exact order, then things are in an ideal state as the eventual spanner column labels will form from this neighboring. When using `tab_spanner_delim()` here with delim set as "." we get the following text fragments:

`province.NL_ZH.pop` -> `"province"`, `"NL_ZH"`, `"pop"`

`province.NL_ZH.gdp` -> `"province"`, `"NL_ZH"`, `"gdp"`

`province.NL_NH.pop` -> `"province"`, `"NL_NH"`, `"pop"`

`province.NL_NH.gdp` -> `"province"`, `"NL_NH"`, `"gdp"`

This gives us the following arrangement of column labels and spanner labels:

```
--------- `"province"` ---------- <- level 2 spanner
---`"NL_ZH"`--- | ---`"NL_NH"`--- <- level 1 spanners
`"pop"`|`"gdp"` | `"pop"`|`"gdp"` <- column labels
---------------------------------
```

There might be situations where the same delimiter is used throughout but only the last instance requires a splitting. With a pair of column names like `north_holland_pop` and `north_holland_area` you would only want `"pop"` and `"area"` to be column labels underneath a single spanner (`"north_holland"`). To achieve this, the split and limit arguments are used and the values for each need to be `split = "last"` and `limit = 1`. This will give us the following arrangement:

```
--`"north_holland"`-- <- level 1 spanner
 `"pop"`  |  `"area"` <- column labels
---------------------
```

With a subset of the towny dataset, we can create a **gt** table and then use the `tab_spanner_delim()` function to automatically generate column spanner labels. In this case we have some column names in the form `population_<year>`. The underscore character is the delimiter that separates a common word `"population"` and a year value. In this default way of splitting, fragments to the right are lowest (really they become new column labels) and moving left we get spanners. Let's have a look at how `tab_spanner_delim()` handles these column names:

```{r}
towny_subset_gt <-
  towny |>
  dplyr::select(name, starts_with("population")) |>
  dplyr::filter(grepl("^F", name)) |>
  gt() |>
  tab_spanner_delim(delim = "_") |>
  fmt_integer()

towny_subset_gt
```

The spanner created through this use of `tab_spanner_delim()` is automatically given an ID value by **gt**. Because it's hard to know what the ID value is, we can use `tab_info()` to inspect the table's indices and ID values.

```{r}
towny_subset_gt |> tab_info()
```

From this informational table, we see that the ID for the spanner is `"spanner-population_1996"`. Also, the columns are still accessible by the original column names (`tab_spanner_delim()` did change their labels though). Let's use `tab_style()` to add some styles to the `towny_subset_gt` table.

```{r}
towny |>
  dplyr::select(name, starts_with("population")) |>
  dplyr::filter(grepl("^F", name)) |>
  gt() |>
  tab_spanner_delim(delim = "_") |>
  fmt_integer() |>
  tab_style(
    style = cell_fill(color = "aquamarine"),
    locations = cells_body(columns = population_2021)
  ) |>
  tab_style(
    style = cell_text(transform = "capitalize"),
    locations = cells_column_spanners(spanners = "spanner-population_1996")
  )
```

We can plan ahead a bit and refashion the column names with **dplyr** before introducing the table to `gt()` and `tab_spanner_delim()`. Here the column labels have underscore delimiters where splitting is not wanted (so a period or space character is used instead). The usage of `tab_spanner_delim()` gives two levels of spanners. We can further touch up the labels after that with `cols_label_with()` and `text_transform()`.

```{r}
towny |>
  dplyr::arrange(desc(population_2021)) |>
  dplyr::slice_head(n = 5) |>
  dplyr::select(name, ends_with("pct")) |>
  dplyr::rename_with(
    .fn = function(x) {
      x |>
        gsub("(.*?)_(\\d{4})", "\\1.\\2", x = _) |>
        gsub("pop_change", "Population Change", x = _)
    }
  ) |>
  gt(rowname_col = "name") |>
  tab_spanner_delim(delim = "_") |>
  fmt_number(decimals = 1, scale_by = 100) |>
  cols_label_with(
    fn = function(x) gsub("pct", "%", x)
  ) |>
  text_transform(
    fn = function(x) gsub("\\.", " - ", x),
    locations = cells_column_spanners()
  ) |>
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = "padding-right: 36px;",
    locations = cells_body()
  )
```

With a summarized, filtered, and pivoted version of the `pizzaplace` dataset, we can create another **gt** table and then use the `tab_spanner_delim()` function with the same delimiter/separator that was used in the **tidyr** `pivot_wider()` call. We can also process the generated column labels with `cols_label_with()`.

```{r}
pizzaplace |>
  dplyr::select(name, date, type, price) |>
  dplyr::group_by(name, date, type) |>
  dplyr::summarize(revenue = sum(price), sold = n(), .groups = "drop") |>
  dplyr::filter(date %in% c("2015-01-01", "2015-01-02", "2015-01-03")) |>
  dplyr::filter(type %in% c("classic", "veggie")) |>
  tidyr::pivot_wider(
    names_from = date,
    names_sep = ".",
    values_from = c(revenue, sold),
    values_fn = sum,
    names_sort = TRUE
  ) |>
  gt(rowname_col = "name", groupname_col = "type") |>
  tab_spanner_delim(delim = ".") |>
  sub_missing(missing_text = "") |>
  fmt_currency(columns = starts_with("revenue")) |>
  data_color(
    columns = starts_with("revenue"),
    method = "numeric",
    palette = c("white", "lightgreen")
  ) |>
  cols_label_with(
    fn = function(x) {
      paste0(x, " (", vec_fmt_datetime(x, format = "E"), ")")
    }
  )
```



## The stub and row groups

- `tab_row_group()`

Create a row group with a collection of rows. This requires specification of the rows to be included, either by supplying row labels, row indices, or through use of a select helper function like `starts_with()`. To modify the order of row groups, use the `row_group_order()` function.

To set a default row group label for any rows not formally placed in a row group, we can use a separate call to `tab_options(row_group.default_label = <label>)`. If this is not done and there are rows that haven't been placed into a row group (where one or more row groups already exist), those rows will be automatically placed into a row group without a label. To restore labels for row groups not explicitly assigned a group, `tab_options(row_group.default_label = "")` can be used.

Using a subset of the `gtcars` dataset, let's create a simple **gt** table with row labels (from the `model` column) inside of a stub. This eight-row table begins with no row groups at all but with a single use of the `tab_row_group()` function, we can specify a row group that will contain any rows where the car model begins with a number.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  )
```

This actually makes two row groups since there are row labels that don't
begin with a number. That second row group is a catch-all `NA` group, and it
doesn't display a label at all. Rather, it is set off from the other group
with a double line. This may be a preferable way to display the arrangement
of one distinct group and an 'others' or default group. If that's the case
but you'd like the order reversed, the `row_group_order()` function can be
used for that.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered"))
```

Two more options include: (1) setting a default label for the 'others' group
(done through `tab_options()]`, and (2) creating row groups until there are
no more unaccounted for rows. Let's try the first option in the next example:

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered")) |>
  tab_options(row_group.default_label = "others")
```

The above use of the `row_group.default_label` in `tab_options()` gets the
job done and provides a default label. One drawback is that the default/`NA`
group doesn't have an ID, so it can't as easily be styled with `tab_style()`;
however, row groups have indices and the index for the `"others"` group here
is `1`.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered")) |>
  tab_options(row_group.default_label = "others") |>
  tab_style(
    style = cell_fill(color = "bisque"),
    locations = cells_row_groups(groups = 1)
  ) |>
  tab_style(
    style = cell_fill(color = "lightgreen"),
    locations = cells_row_groups(groups = "numbered")
  )
```

Now let's try using `tab_row_group()` with our `gtcars`-based table such
that all rows are formally assigned to different row groups. We'll define two
row groups with the (Markdown-infused) labels `"**Powerful Cars**"` and
`"**Super Powerful Cars**"`. The distinction between the groups is whether
`hp` is lesser or greater than `600` (and this is governed by the expressions
provided to the `rows` argument).

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = md("**Powerful Cars**"),
    rows = hp < 600,
    id = "powerful"
  ) |>
  tab_row_group(
    label = md("**Super Powerful Cars**"),
    rows = hp >= 600,
    id = "v_powerful"
  ) |>
  tab_style(
    style = cell_fill(color = "gray85"),
    locations = cells_row_groups(groups = "powerful")
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "gray95"),
      cell_text(size = "larger")
    ),
    locations = cells_row_groups(groups = "v_powerful")
  )
```

Setting the `id` values for each of the row groups makes things easier since
you will have clean, markup-free ID values to reference in later calls (as
was done with the `tab_style()` invocations in the example above). The use of
the `md()` helper function makes it so that any Markdown provided for the
`label` of a row group is faithfully rendered.

- `row_group_order()`

- `tab_stubhead()`

Add a label to the stubhead of a **gt** table. The stubhead is the lone element that is positioned left of the column labels, and above the stub. If a stub does not exist, then there is no stubhead (so no change will be made when using this function in that case). We have the flexibility to use Markdown formatting for the stubhead label. Furthermore, if the table is intended for HTML output, we can use HTML for the stubhead label.

Using a small subset of the `gtcars` dataset, we can create a **gt** table with row labels. Since we have row labels in the stub (via use of `rowname_col = "model"` in the `gt()` function call) we have a stubhead, so, let's add a stubhead label (`"car"`) with the `tab_stubhead()` function to describe what's in the stub.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:5) |>
  gt(rowname_col = "model") |>
  tab_stubhead(label = "car")
```

- `tab_stub_indent()`


## Adding footnotes

- `tab_footnote()` and the `cells_*()` location helpers
- `opt_footnote_*()`

