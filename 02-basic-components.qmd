# Basic components of a table and how to incorporate those

```{r setup, include=FALSE, echo=FALSE}
library(gt)
library(dplyr)
library(tidyr)
```

## Making a **gt** table: the `gt()` function is the entry point

When one provides table data to the `gt()` function, it generates a **gt** table object. This function is the initial step in a typical **gt** workflow. Once you possess the **gt** table object, you have the ability to perform styling transformations before rendering it as a display table of different formats.

### `gt()`

*** General introduction to the `gt()` function


```r
gt(
  data,
  rowname_col = "rowname",
  groupname_col = dplyr::group_vars(data),
  process_md = FALSE,
  caption = NULL,
  rownames_to_stub = FALSE,
  row_group_as_column = FALSE,
  auto_align = TRUE,
  id = NULL,
  locale = NULL,
  row_group.sep = getOption("gt.row_group.sep", " - ")
)
```

<hr>

**`data`**: *Input data table*

`obj:<data.frame>|obj:<tbl_df>` // **required**

A `data.frame` object or a tibble (`tbl_df`).

<hr>

**`rowname_col`**:  Column for row names/labels from data

`scalar<character>` // default: `NULL`, so *optional*

The column name in the input data table to use as row labels to be placed in the table stub. If the `rownames_to_stub` option is `TRUE` then any column name provided to `rowname_col` will be ignored.

<hr>

**`groupname_col`**: *Column for group names/labels from data*

`scalar<character>` // default: `NULL`, so *optional*

The column name in the input data table to use as group labels for generation of stub row groups. If the input data table has the `grouped_df` class (through use of the `dplyr::group_by()` function or associated `group_by*()` functions) then any input here is ignored.

<hr>

**`process_md`**: *Process Markdown in `rowname_col` and `groupname_col`*

`scalar<logical>` // default: `FALSE`

Should the contents of the `rowname_col` and `groupname_col` be interpreted as Markdown? By default this won't happen.

<hr>

**`caption`**: *Table caption text*

`scalar<character>` // default: `NULL`, so *optional*

An optional table caption to use for cross-referencing in **R Markdown**, **Quarto**, or **bookdown**.

<hr>

**`rownames_to_stub`**: *Use data frame row labels in the stub*

`scalar<logical>` // default: `FALSE`

An option to take rownames from the input data table (should they be available) as row labels in the display table stub.

<hr>

**`row_group_as_column`**: *Mode for displaying row group labels in the stub*

`scalar<logical>` // default: `FALSE`

An option that alters the display of row group labels. By default this is `FALSE` and row group labels will appear in dedicated rows above their respective groups of rows. If `TRUE` row group labels will occupy a secondary column in the table stub.

<hr>

**`auto_align`**: *Automatic alignment of column values and labels*

`scalar<logical>` // default: `TRUE`

Optionally have column data be aligned depending on the content contained in each column of the input data. Internally, this calls `cols_align(align = "auto")` for all columns.

<hr>

**`id`**: *The table ID*

`scalar<character>` // default: `NULL`, so *optional*

By default (with `NULL`) this will be a random, ten-letter ID as generated by using the `random_id()` function. A custom table ID can be used be providing a single-length character vector.

<hr>

**`locale`**: *Locale identifier*

`scalar<character>` // default: `NULL`, so *optional*

An optional locale identifier that can be set as the default locale for all functions that take a locale argument. Examples include `"en"` for English (United States) and `"fr"` for French (France). We can use the `info_locales()` function as a useful reference for all of the locales that are supported.

<hr>

**`row_group.sep`**: *Separator text for multiple row group labels*

`scalar<character>` // default: `getOption("gt.row_group.sep", " - ")`

The separator to use between consecutive group names (a possibility when providing `data` as a `grouped_df` with multiple groups) in the displayed row group label.

<hr>

Let's use the `exibble` dataset for the next few examples, we'll learn how to make simple **gt** tables with the `gt()` function. The most basic thing to do is to just use `gt()` with the dataset as the input.

```{r}
exibble |> gt()
```

This dataset has the row and group columns. The former contains unique values that are ideal for labeling rows, and this often happens in what is called the 'stub' (a reserved area that serves to label rows). With the `gt()` function, we can immediately place the contents of the row column into the stub column. To do this, we use the `rowname_col` argument with the name of the column to use in quotes.

```{r}
exibble |> gt(rowname_col = "row")
```

This sets up a table with a stub, the row labels are placed within the stub column, and a vertical dividing line has been placed on the right-hand side.

The `group` column can be used to divide the rows into discrete groups. Within that column, we see repetitions of the values `"grp_a"` and `"grp_b"`. These serve both as ID values and the initial label for the groups. With the `groupname_col` argument in `gt()`, we can set up the row groups immediately upon creation of the table.

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group"
  )
```

If you'd rather perform the set up of row groups later (i.e., not in the `gt()` call), this is possible with use of the `tab_row_group()` function (and `row_group_order()` can help with the arrangement of row groups).

One more thing to consider with row groups is their layout. By default, row group labels reside in separate rows the appear above the group. However, we can use the `row_group_as_column = TRUE` option to put the row group labels within a secondary column within the table stub.

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group",
    row_group_as_column = TRUE
  )
```

This could be done later if need be, and using `tab_options(row_group.as_column = TRUE)` would be the way to do it outside of the `gt()` call.

Some datasets have rownames built in; `mtcars` famously has the car model names as the rownames. To use those rownames as row labels in the stub, the `rownames_to_stub = TRUE` option will prove to be useful.

```{r}
head(mtcars, 10) |> gt(rownames_to_stub = TRUE)
```

By default, values in the body of a **gt** table (and their column labels) are automatically aligned. The alignment is governed by the types of values in a column. If you'd like to disable this form of auto-alignment, the `auto_align = FALSE` option can be taken.

```{r}
exibble |> gt(rowname_col = "row", auto_align = FALSE)
```

What you'll get from that is center-alignment of all table body values and all column labels. Note that row labels in the the stub are still left-aligned; and auto_align has no effect on alignment within the table stub.

However which way you generate the initial **gt** table object, you can use it with a huge variety of functions in the package to further customize the presentation. Formatting body cells is commonly done with the family of formatting functions (e.g., `fmt_number()`, `fmt_date()`, etc.). The package supports formatting with internationalization ('i18n' features) and so locale-aware functions come with a locale argument. To avoid having to use that argument repeatedly, the `gt()` function has its own locale argument. Setting a locale in that will make it available globally. Here's an example of how that works in practice when setting `locale = "fr"` in `gt()` and using formatting functions:

```{r}
exibble |>
  gt(
    rowname_col = "row",
    groupname_col = "group",
    locale = "fr"
  ) |>
  fmt_number() |>
  fmt_date(
    columns = date,
    date_style = "yMEd"
  ) |>
  fmt_datetime(
    columns = datetime,
    format = "EEEE, MMMM d, y",
    locale = "en"
  )
```

In this example, the `fmt_number()` and `fmt_date()` functions understand that the locale for this table is `"fr"` (French), so the appropriate formatting for that locale is apparent in the `num`, `currency`, and `date` columns. However in the `fmt_datetime()` call, we explicitly use the `"en"` (English) locale. This overrides the `"fr"` default set for this table and the end result is dates formatted with the English locale in the datetime column.

## The table header and footer

It's possible to add a table header to the **gt** table, which includes a title and even a subtitle. The table header is an optional component of the table that appears above the column labels. You have the flexibility to use Markdown formatting for the header's title and subtitle, allowing for greater customization. Additionally, if you intend to use HTML output for the table, you may utilize HTML in either the title or subtitle.

### `tab_header()`


```r
tab_header(
  data,
  title,
  subtitle = NULL,
  preheader = NULL
)
```

<hr>

**`title`**: *Header title*

`scalar<character>` // **required**

Text to be used in the table title. We can elect to use the `md()` and `html()` helper functions to style the text as Markdown or to retain HTML elements in the text.

<hr>

**`subtitle`**: *Header subtitle*

`scalar<character>` // default: `NULL`, so *optional*

Text to be used in the table subtitle. Again, we use the `md()` and `html()` helper functions as with `title`.

<hr>

**`preheader`**: *RTF preheader text*

`vector<character>` // default: `NULL`, so *optional*

Optional preheader content that is rendered above the table for RTF output. Can be supplied as a vector of text.

<hr>

Use the `gtcars` dataset to create a **gt** table. Add a header part to the table with the `tab_header()` function. We'll add a title and the optional subtitle as well. With the `md()` helper function, we can make sure the Markdown formatting is interpreted and transformed.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title = md("Data listing from **gtcars**"),
    subtitle = md("`gtcars` is an R dataset")
  )
```

If the table is intended solely as an HTML table, you could introduce your own HTML elements into the header. You can even use the **htmltools** package to help arrange and generate the HTML. Here's an example of that, where two `<div>` elements are placed in a `htmltools::tagList()`.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title =
      htmltools::tagList(
        htmltools::tags$div(
          style = htmltools::css(
            `text-align` = "center"
          ),
          htmltools::HTML(
            web_image("https://www.r-project.org/logo/Rlogo.png")
          )
        ),
        htmltools::tags$div(
          "Data listing from ",
          htmltools::tags$strong("gtcars")
        )
      )
  )
```

If using HTML but doing something far simpler, we can use the `html()` helper function to declare that the text provided is HTML.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_header(
    title = html("Data listing from <strong>gtcars</strong>"),
    subtitle = html("From <span style='color:red;'>gtcars</span>")
  )
```

### `opt_align_header()`


```r
opt_align_table_header(
  data,
  align = c("left", "center", "right")
)
```

<hr>

**`align`**: *Header alignment*

`singl-kw:[left|center|right]` // default: `"left"`

The alignment of the title and subtitle elements in the table header. Options are `"left"` (the default), `"center"`, or `"right"`.

<hr>

The table header that is appended to a **gt** table typically has center alignment for both the title and subtitle elements. However, it is possible to adjust the horizontal alignment of the title and subtitle by utilizing the `align` argument. This function provides a quick and easy means to set the alignment to the left or right. It also serves as a convenient shortcut for `<gt_tbl> |> tab_options(heading.align = <align>)`.

```{r}
exibble |>
  gt(rowname_col = "row", groupname_col = "group") |>
  tab_header(
    title = "The title of the table",
    subtitle = "The table's subtitle"
  ) |>
  opt_align_table_header(align = "left")
```

## Adding *source notes* to the footer of the table

*** General introduction to the table footer

A source note is useful for citing the data included in the table.

### `tab_source_note()`

It's possible to add a source note to the footer part of the **gt** table with `tab_source_note()`. Several of these can be added to the footer and, to do that, we can simply use multiple calls of `tab_source_note()` (they will be inserted in the order provided). We can use Markdown formatting for the note, or, if the table is intended for HTML output, we can include HTML formatting.

Here is the function's signature and descriptions of its arguments:

```r
tab_source_note(
  data,
  source_note
)
```

<hr>

**`source_note`**: *Source note text*

`scalar<character>` // **required**

The text to use for a source note. We can optionally use the `md()` or `html()` functions to style the text as Markdown or to retain HTML elements in the text.

<hr>

With three columns from the `gtcars` dataset, let's create a **gt** table. We can use the `tab_source_note()` function to add a source note to the table footer. Here we are citing the data source but this function can be used for any text you'd prefer to display in the footer section.

```{r}
gtcars |>
  dplyr::select(mfr, model, msrp) |>
  dplyr::slice(1:5) |>
  gt() |>
  tab_source_note(source_note = "From edmunds.com")
```

## Grouping together column labels with spanners

*** General introduction to table spanners

The part of the table that contains, at a minimum, column labels and, optionally, spanner labels is sometimes called the table boxhead. A spanner will occupy space over any number of contiguous column labels. With the `tab_spanner()` function, you can insert a spanner in the boxhead part of a **gt** table. This function allows for mapping to be defined by column names, existing spanner ID values, or a mixture of both. 


### `tab_spanner()`

With the `tab_spanner()` function, you can insert a spanner above column labels or existing spanners in the boxhead part of a **gt** table.

Here is the function's signature and descriptions of its arguments:

```r
tab_spanner(
  data,
  label,
  columns = NULL,
  spanners = NULL,
  level = NULL,
  id = label,
  gather = TRUE,
  replace = FALSE
)
```

<hr>

**`label`**: *Spanner label text*

`scalar<character>` // **required**

The text to use for the spanner label. We can optionally use the `md()` or `html()` functions to style the text as Markdown or to retain HTML elements in the text.

<hr>

**`columns`**: *Columns to target*

`<column-targeting expression>` // default: `NULL`, so *optional*

The columns to serve as components of the spanner.

<hr>

**`spanners`**: *Spanners to target*

`vector<character>` // default: `NULL`, so *optional*

The spanners that should be spanned over, should they already be defined. One or more spanner ID values (in quotes) can be supplied here. This argument works in tandem with the `columns` argument.

<hr>

**`level`**: *Spanner level for insertion*

`scalar<numeric|integer>` // default: `NULL`, so *optional*

An explicit level to which the spanner should be placed. If not provided, **gt** will choose the level based on the inputs provided within columns and spanners, placing the spanner label where it will fit. The first spanner level (right above the column labels) is `1`.

<hr>

**`id`**: *Spanner ID*

`scalar<character>` // default: `label`

The ID for the spanner. When accessing a spanner through the spanners argument of `tab_spanner()` or `cells_column_spanners()` (when using `tab_style()` or `tab_footnote()`) the `id` value is used as the reference (and not the label). If an `id` is not explicitly provided here, it will be taken from the label value. It is advisable to set an explicit `id` value if you plan to access this cell in a later function call and the label text is complicated (e.g., contains markup, is lengthy, or both). Finally, when providing an `id` value you must ensure that it is unique across all ID values set for spanner labels (the function will stop if `id` isn't unique).

<hr>

**`gather`**: *Gather columns together*

`scalar<logical>` // default: `TRUE`

An option to move the specified columns such that they are unified under the spanner. Ordering of the moved-into-place columns will be preserved in all cases.

<hr>

**`replace`**: *Replace existing spanners*

`scalar<logical>` // default: `FALSE`

Should new spanners be allowed to partially or fully replace existing spanners? (This is a possibility if setting spanners at an already populated level.) By default, this is set to `FALSE` and an error will occur if some replacement is attempted.

<hr>

The spanners are placed in the order of calling `tab_spanner()` so if a later call uses the same columns in its definition (or even a subset) as the first invocation, the second spanner will be overlaid atop the first. Options exist for forcibly inserting a spanner underneath other (with `level` as space permits) and with `replace`, which allows for full or partial spanner replacement.

Let's create a **gt** table using a small portion of the `gtcars` dataset. Over several columns (`hp`, `hp_rpm`, `trq`, `trq_rpm`, `mpg_c`, `mpg_h`) we'll use `tab_spanner()` to add a spanner with the label `"performance"`. This effectively groups together several columns related to car performance under a unifying label.

```{r}
gtcars |>
  dplyr::select(
    year, bdy_style, starts_with(c("hp", "trq", "mpg")), msrp
  ) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_spanner(
    label = "performance",
    columns = starts_with(c("hp", "trq", "mpg"))
  )
```

Notice that in the above table code, we used the `starts_with()` selection helper in both the **dplyr** `select()` statement and in the **gt** `tab_spanner()` statement. Such use of tidyselect selection helpers is incredibly helpful for shortening the amount of code supplied in the `columns` argument across many **gt** functions.

With the default `gather = TRUE` option, columns selected for a particular spanner will be moved so that there is no separation between them. This can be seen with the example below that uses a subset of the `towny` dataset. The starting column order is `name`, `latitude`, `longitude`, `population_2016`, `density_2016`, `population_2021`, and `density_2021`. The first two uses of `tab_spanner()` deal with making separate spanners for the two population and two density columns. After their use, the columns are moved to this new ordering: `name`, `latitude`, `longitude`, `population_2016`, `population_2021`, `density_2016`, and `density_2021`. The third and final call of `tab_spanner()` doesn't further affect the ordering of columns.

```{r}
towny |>
  dplyr::arrange(desc(population_2021)) |>
  dplyr::slice_head(n = 5) |>
  dplyr::select(
    name, latitude, longitude,
    ends_with("2016"), ends_with("2021")
  ) |>
  gt() |>
  tab_spanner(
    columns = starts_with("pop"),
    label = "Population"
  ) |>
  tab_spanner(
    columns = starts_with("den"),
    label = "Density"
  ) |>
  tab_spanner(
    columns = ends_with("itude"),
    label = md("*Location*"),
    id = "loc"
  )
```

While columns are moved, it is only the minimal amount of moving required (pulling in columns from the right) to ensure that columns are gathered under the appropriate spanners. With the last call, there are two more things to note: (1) `label` values can use the `md()` (or `html()`) helper functions to help create styled text, and (2) an `id` value may be supplied for reference later (e.g., for styling with `tab_style()` or applying footnotes with `tab_footnote()`).

It's possible to stack multiple spanners atop each other with consecutive calls of `tab_spanner()`. It's a bit like playing Tetris: putting a spanner down anywhere there is another spanner (i.e., there are one or more shared columns) means that second spanner will reside a level above prior. Let's look at a few examples at how this works, and we'll also explore a few lesser-known placement tricks. Let's use a cut down version of `exibble` for this, set up a few level-one spanners, and then place a level two spanner over two other spanners.

```{r}
exibble_narrow <- exibble |> dplyr::slice_head(n = 3)

exibble_narrow |>
  gt() |>
  tab_spanner(
    label = "Row Information",
    columns = c(row, group)
  ) |>
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |>
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |>
  tab_spanner(
    label = "Numbers and Text",
    spanners = c("num_spanner", "text_spanner")
  )
```

In the above example, we used the `spanners` argument to define where the `"Numbers and Text"`-labeled spanner should reside. For that, we supplied the `"num_spanner"` and `"text_spanner"` ID values for the two spanners associated with the `num`, `currency`, `char`, and `fctr` columns. Alternatively, we could have given those column names to the `columns` argument and achieved the same result. You could actually use a combination of `spanners` and `columns` to define where the spanner should be placed. Here is an example of just that:

```{r}
exibble_narrow_gt <-
  exibble_narrow |>
  gt() |>
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |>
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |>
  tab_spanner(
    label = "Text, Dates, Times, Datetimes",
    columns = contains(c("date", "time")),
    spanners = "text_spanner"
  )
  
exibble_narrow_gt
```

And, again, we could have solely supplied all of the column names to `columns` instead of using this hybrid approach, but it is interesting to express the definition of spanners with this flexible combination. What if you wanted to extend the above example and place a spanner above the `date`, `time`, and `datetime` columns? If you tried that in the manner as exemplified above, the spanner will be placed in the third level of spanners:

```{r}
exibble_narrow_gt |>
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    id = "date_time_spanner"
  )
```

Remember that the approach taken by `tab_spanner()` is to keep stacking atop existing spanners. But, there is space next to the `"Text Values"` spanner on the first level. You can either revise the order of `tab_spanner()` calls, or, use the `level` argument to force the spanner into that level (so long as there is space).

```{r}
exibble_narrow_gt |>
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    level = 1,
    id = "date_time_spanner"
  )
```

That puts the spanner in the intended level. If there aren't free locations available in the `level` specified you'll get an error stating which columns cannot be used for the new spanner (this can be circumvented, if necessary, with the `replace = TRUE` option). If you choose a level higher than the maximum occupied, then the spanner will be dropped down. Again, these behaviors are indicative of Tetris-like rules though they tend to work well for the application of spanners.

### `tab_spanner_delim()`

The `cols_spanner_delim()` function can take specially-crafted column names and generate one or more spanner column labels (along with relabeling the column labels).


```r
tab_spanner_delim(
  data,
  delim,
  columns = everything(),
  split = c("last", "first"),
  limit = NULL,
  reverse = FALSE
)
```

<hr>

**`delim`**: *Delimiter for splitting*

`scalar<character>` // **required**

The delimiter to use to split an input column name. This should be a single character (e.g., `"_"`, `"."`, etc.).

<hr>

**`columns`**: *Columns to target*

`<column-targeting expression>` // default: `everything()`

The columns to consider for the splitting, relabeling, and spanner setting operations.

<hr>

**`split`**: *Splitting side*

`singl-kw:[last|first]` // default: `"last"`

Should the delimiter splitting occur from the `"last"` instance of the delim character or from the `"first"`? The default here uses the `"last"` keyword, and splitting begins at the last instance of the delimiter in the column name. This option only has some consequence when there is a limit value applied that is lesser than the number of delimiter characters for a given column name (i.e., number of splits is not the maximum possible number).

<hr>

**`limit`**: *Limit for splitting*

`scalar<numeric|integer|character>` // default: `NULL`, so *optional*

An optional limit to place on the splitting procedure. The default `NULL` means that a column name will be split as many times are there are delimiter characters. In other words, the default means there is no limit. If an integer value is given to limit then splitting will cease at the iteration given by limit. This works in tandem with split since we can adjust the number of splits from either the right side (`split = "last"`) or left side (`split = "first"`) of the column name.

<hr>

**`reverse`**: *Reverse vector of split names*

`scalar<logical>` // default: `FALSE`

Should the order of split names be reversed? By default, this is `FALSE`.

<hr>

This is done by splitting the column name by a specified delimiter character (this is the `delim`) and placing the fragments from top to bottom (i.e., higher-level spanners to the column labels). Furthermore, the neighboring text fragments on different spanner levels will be coalesced together to put the span back into spanner. For instance, having the three side-by-side column names `rating_1`, `rating_2`, and `rating_3` will (in the default case at least) result in a spanner with the label `"rating"` above columns with the labels `"1"`, `"2"`, and `"3"`.

If we take a hypothetical table that includes the column names `province.NL_ZH.pop`, `province.NL_ZH.gdp`, `province.NL_NH.pop`, and `province.NL_NH.gdp`, we can see that we have a naming system that has a well-defined structure. We start with the more general to the left (`"province"`) and move to the more specific on the right (`"pop"`). If the columns are in the table in this exact order, then things are in an ideal state as the eventual spanner column labels will form from this neighboring. When using `tab_spanner_delim()` here with delim set as "." we get the following text fragments:

`province.NL_ZH.pop` -> `"province"`, `"NL_ZH"`, `"pop"`

`province.NL_ZH.gdp` -> `"province"`, `"NL_ZH"`, `"gdp"`

`province.NL_NH.pop` -> `"province"`, `"NL_NH"`, `"pop"`

`province.NL_NH.gdp` -> `"province"`, `"NL_NH"`, `"gdp"`

This gives us the following arrangement of column labels and spanner labels:

```
--------- `"province"` ---------- <- level 2 spanner
---`"NL_ZH"`--- | ---`"NL_NH"`--- <- level 1 spanners
`"pop"`|`"gdp"` | `"pop"`|`"gdp"` <- column labels
---------------------------------
```

There might be situations where the same delimiter is used throughout but only the last instance requires a splitting. With a pair of column names like `north_holland_pop` and `north_holland_area` you would only want `"pop"` and `"area"` to be column labels underneath a single spanner (`"north_holland"`). To achieve this, the split and limit arguments are used and the values for each need to be `split = "last"` and `limit = 1`. This will give us the following arrangement:

```
--`"north_holland"`-- <- level 1 spanner
 `"pop"`  |  `"area"` <- column labels
---------------------
```

With a subset of the towny dataset, we can create a **gt** table and then use the `tab_spanner_delim()` function to automatically generate column spanner labels. In this case we have some column names in the form `population_<year>`. The underscore character is the delimiter that separates a common word `"population"` and a year value. In this default way of splitting, fragments to the right are lowest (really they become new column labels) and moving left we get spanners. Let's have a look at how `tab_spanner_delim()` handles these column names:

```{r}
towny_subset_gt <-
  towny |>
  dplyr::select(name, starts_with("population")) |>
  dplyr::filter(grepl("^F", name)) |>
  gt() |>
  tab_spanner_delim(delim = "_") |>
  fmt_integer()

towny_subset_gt
```

The spanner created through this use of `tab_spanner_delim()` is automatically given an ID value by **gt**. Because it's hard to know what the ID value is, we can use `tab_info()` to inspect the table's indices and ID values.

```{r}
towny_subset_gt |> tab_info()
```

From this informational table, we see that the ID for the spanner is `"spanner-population_1996"`. Also, the columns are still accessible by the original column names (`tab_spanner_delim()` did change their labels though). Let's use `tab_style()` to add some styles to the `towny_subset_gt` table.

```{r}
towny |>
  dplyr::select(name, starts_with("population")) |>
  dplyr::filter(grepl("^F", name)) |>
  gt() |>
  tab_spanner_delim(delim = "_") |>
  fmt_integer() |>
  tab_style(
    style = cell_fill(color = "aquamarine"),
    locations = cells_body(columns = population_2021)
  ) |>
  tab_style(
    style = cell_text(transform = "capitalize"),
    locations = cells_column_spanners(spanners = "spanner-population_1996")
  )
```

We can plan ahead a bit and refashion the column names with **dplyr** before introducing the table to `gt()` and `tab_spanner_delim()`. Here the column labels have underscore delimiters where splitting is not wanted (so a period or space character is used instead). The usage of `tab_spanner_delim()` gives two levels of spanners. We can further touch up the labels after that with `cols_label_with()` and `text_transform()`.

```{r}
towny |>
  dplyr::arrange(desc(population_2021)) |>
  dplyr::slice_head(n = 5) |>
  dplyr::select(name, ends_with("pct")) |>
  dplyr::rename_with(
    .fn = function(x) {
      x |>
        gsub("(.*?)_(\\d{4})", "\\1.\\2", x = _) |>
        gsub("pop_change", "Population Change", x = _)
    }
  ) |>
  gt(rowname_col = "name") |>
  tab_spanner_delim(delim = "_") |>
  fmt_number(decimals = 1, scale_by = 100) |>
  cols_label_with(
    fn = function(x) gsub("pct", "%", x)
  ) |>
  text_transform(
    fn = function(x) gsub("\\.", " - ", x),
    locations = cells_column_spanners()
  ) |>
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = "padding-right: 36px;",
    locations = cells_body()
  )
```

With a summarized, filtered, and pivoted version of the `pizzaplace` dataset, we can create another **gt** table and then use the `tab_spanner_delim()` function with the same delimiter/separator that was used in the **tidyr** `pivot_wider()` call. We can also process the generated column labels with `cols_label_with()`.

```{r}
pizzaplace |>
  dplyr::select(name, date, type, price) |>
  dplyr::group_by(name, date, type) |>
  dplyr::summarize(revenue = sum(price), sold = n(), .groups = "drop") |>
  dplyr::filter(date %in% c("2015-01-01", "2015-01-02", "2015-01-03")) |>
  dplyr::filter(type %in% c("classic", "veggie")) |>
  tidyr::pivot_wider(
    names_from = date,
    names_sep = ".",
    values_from = c(revenue, sold),
    values_fn = sum,
    names_sort = TRUE
  ) |>
  gt(rowname_col = "name", groupname_col = "type") |>
  tab_spanner_delim(delim = ".") |>
  sub_missing(missing_text = "") |>
  fmt_currency(columns = starts_with("revenue")) |>
  data_color(
    columns = starts_with("revenue"),
    method = "numeric",
    palette = c("white", "lightgreen")
  ) |>
  cols_label_with(
    fn = function(x) {
      paste0(x, " (", vec_fmt_datetime(x, format = "E"), ")")
    }
  )
```


## The stub and row groups

*** General introduction to the table stub


### `tab_row_group()`

Create a row group with a collection of rows. This requires specification of the rows to be included, either by supplying row labels, row indices, or through use of a select helper function like `starts_with()`. 

```r
tab_row_group(
  data,
  label,
  rows,
  id = label
)
```

<hr>

**`label`**: *Row group label text*

`scalar<character>` // **required**

The text to use for the row group label. We can optionally use the `md()` and `html()` functions to style the text as Markdown or to retain HTML elements in the text.

<hr>

**`rows`**: *Rows to target*

`<row-targeting expression>` // **required**

The rows to be made components of the row group. We can supply a vector of row captions within `c()`, a vector of row indices, or a select helper function. We can also use expressions to filter down to the rows we need (e.g., `[colname_1] > 100 & [colname_2] < 50`).

<hr>

**`id`**: *Row group ID*

`scalar<character>` // default: `label`

The ID for the row group. When accessing a row group through `cells_row_groups()` (when using `tab_style()` or `tab_footnote()`) the `id` value is used as the reference (and not the label). If an `id` is not explicitly provided here, it will be taken from the `label` value. It is advisable to set an explicit `id` value if you plan to access this cell in a later function call and the `label` text is complicated (e.g., contains markup, is lengthy, or both). Finally, when providing an `id` value you must ensure that it is unique across all ID values set for row groups (the function will stop if `id` isn't unique).

<hr>

To set a default row group label for any rows not formally placed in a row group, we can use a separate call to `tab_options(row_group.default_label = <label>)`. If this is not done and there are rows that haven't been placed into a row group (where one or more row groups already exist), those rows will be automatically placed into a row group without a label. To restore labels for row groups not explicitly assigned a group, `tab_options(row_group.default_label = "")` can be used.

Using a subset of the `gtcars` dataset, let's create a simple **gt** table with row labels (from the `model` column) inside of a stub. This eight-row table begins with no row groups at all but with a single use of the `tab_row_group()` function, we can specify a row group that will contain any rows where the car model begins with a number.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  )
```

This actually makes two row groups since there are row labels that don't begin with a number. That second row group is a catch-all `NA` group, and it doesn't display a label at all. Rather, it is set off from the other group with a double line. This may be a preferable way to display the arrangement of one distinct group and an 'others' or default group. If that's the case but you'd like the order reversed, the `row_group_order()` function can be used for that.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered"))
```

Two more options include: (1) setting a default label for the 'others' group (done through `tab_options()]`, and (2) creating row groups until there are no more unaccounted for rows. Let's try the first option in the next example:

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered")) |>
  tab_options(row_group.default_label = "others")
```

The above use of the `row_group.default_label` in `tab_options()` gets the job done and provides a default label. One drawback is that the default/`NA` group doesn't have an ID, so it can't as easily be styled with `tab_style()`; however, row groups have indices and the index for the `"others"` group here is `1`.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = "numbered",
    rows = matches("^[0-9]")
  ) |>
  row_group_order(groups = c(NA, "numbered")) |>
  tab_options(row_group.default_label = "others") |>
  tab_style(
    style = cell_fill(color = "bisque"),
    locations = cells_row_groups(groups = 1)
  ) |>
  tab_style(
    style = cell_fill(color = "lightgreen"),
    locations = cells_row_groups(groups = "numbered")
  )
```

Now let's try using `tab_row_group()` with our `gtcars`-based table such that all rows are formally assigned to different row groups. We'll define two row groups with the (Markdown-infused) labels `"**Powerful Cars**"` and `"**Super Powerful Cars**"`. The distinction between the groups is whether `hp` is lesser or greater than `600` (and this is governed by the expressions provided to the `rows` argument).

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:8) |>
  gt(rowname_col = "model") |>
  tab_row_group(
    label = md("**Powerful Cars**"),
    rows = hp < 600,
    id = "powerful"
  ) |>
  tab_row_group(
    label = md("**Super Powerful Cars**"),
    rows = hp >= 600,
    id = "v_powerful"
  ) |>
  tab_style(
    style = cell_fill(color = "gray85"),
    locations = cells_row_groups(groups = "powerful")
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "gray95"),
      cell_text(size = "larger")
    ),
    locations = cells_row_groups(groups = "v_powerful")
  )
```

Setting the `id` values for each of the row groups makes things easier since you will have clean, markup-free ID values to reference in later calls (as was done with the `tab_style()` invocations in the example above). The use of the `md()` helper function makes it so that any Markdown provided for the `label` of a row group is faithfully rendered.

### `row_group_order()`


```r
row_group_order(
  data,
  groups
)
```

<hr>

**`groups`**: *Specification of row group IDs*

`vector<character>` // **required**

A character vector of row group ID values corresponding to the revised ordering. While this vector must contain valid group ID values, it is not required to have all of the row group IDs within it; any omitted values will be added to the end while preserving the original ordering.

<hr>

### `tab_stubhead()`

Add a label to the stubhead of a **gt** table. The stubhead is the lone element that is positioned left of the column labels, and above the stub. If a stub does not exist, then there is no stubhead (so no change will be made when using this function in that case). We have the flexibility to use Markdown formatting for the stubhead label. Furthermore, if the table is intended for HTML output, we can use HTML for the stubhead label.

```r
tab_stubhead(
  data,
  label
)
```

<hr>

**`label`**: *Stubhead label text*

`scalar<character>` // **required**

The text to be used as the stubhead label. We can optionally use the `md()` and `html()` functions to style the text as Markdown or to retain HTML elements in the text.

<hr>

Using a small subset of the `gtcars` dataset, we can create a **gt** table with row labels. Since we have row labels in the stub (via use of `rowname_col = "model"` in the `gt()` function call) we have a stubhead, so, let's add a stubhead label (`"car"`) with the `tab_stubhead()` function to describe what's in the stub.

```{r}
gtcars |>
  dplyr::select(model, year, hp, trq) |>
  dplyr::slice(1:5) |>
  gt(rowname_col = "model") |>
  tab_stubhead(label = "car")
```

### `tab_stub_indent()`

Indentation of row labels is an effective way for establishing structure in a table stub. The `tab_stub_indent()` function allows for fine control over row label indentation in the stub. We can use an explicit definition of an indentation level, or, employ an indentation directive using keywords.

```r
tab_stub_indent(
  data,
  rows,
  indent = "increase"
)
```

<hr>

**`rows`**: *Rows to target*

`<row-targeting expression>` // **required**

The rows to consider for the indentation change. We can supply a vector of row captions within `c()`, a vector of row indices, or a select helper function. We can also use expressions to filter down to the rows we need (e.g., `[colname_1] > 100 & [colname_2] < 50`).

<hr>

**`indent`**: *Indentation directive*

`scalar<character|numeric|integer>` // default: `"increase"`

An indentation directive either as a keyword describing the indentation change or as an explicit integer value for directly setting the indentation level. The keyword `"increase"` (the default) will increase the indentation level by one; `"decrease"` will do the same in the reverse direction. The starting indentation level of `0` means no indentation and this values serves as a lower bound. The upper bound for indentation is at level `5`.

<hr>

Let's use a summarized version of the `pizzaplace` dataset to create a **gt** table with row groups and row labels. With the `summary_rows()` function, we'll generate summary rows at the top of each row group. With `tab_stub_indent()` we can add indentation to the row labels in the stub.

```{r}
pizzaplace |>
  dplyr::group_by(type, size) |>
  dplyr::summarize(
    sold = dplyr::n(),
    income = sum(price),
    .groups = "drop"
  ) |>
  gt(rowname_col = "size", groupname_col = "type") |>
  tab_header(title = "Pizzas Sold in 2015") |>
  fmt_integer(columns = sold) |>
  fmt_currency(columns = income) |>
  summary_rows(
    fns = list(label = "All Sizes", fn = "sum"),
    side = "top",
    fmt = list(
      ~ fmt_integer(., columns = sold),
      ~ fmt_currency(., columns = income)
    )
  ) |>
  tab_options(
    summary_row.background.color = "gray95",
    row_group.background.color = "#FFEFDB",
    row_group.as_column = TRUE
  ) |>
  tab_stub_indent(
    rows = everything(),
    indent = 2
  )
```

